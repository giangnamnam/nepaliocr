<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OCR: HShell.h Source File</title>
<link href="ocr.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Created By Rajesh Pandey   -->
<h1>HShell.h</h1><div class="fragment"><pre>00001 <span class="comment">/* ----------------------------------------------------------- */</span>
00002 <span class="comment">/*                                                             */</span>
00003 <span class="comment">/*                          ___                                */</span>
00004 <span class="comment">/*                       |_| | |_/   SPEECH                    */</span>
00005 <span class="comment">/*                       | | | | \   RECOGNITION               */</span>
00006 <span class="comment">/*                       =========   SOFTWARE                  */</span> 
00007 <span class="comment">/*                                                             */</span>
00008 <span class="comment">/*                                                             */</span>
00009 <span class="comment">/* ----------------------------------------------------------- */</span>
00010 <span class="comment">/* developed at:                                               */</span>
00011 <span class="comment">/*                                                             */</span>
00012 <span class="comment">/*      Speech Vision and Robotics group                       */</span>
00013 <span class="comment">/*      Cambridge University Engineering Department            */</span>
00014 <span class="comment">/*      http://svr-www.eng.cam.ac.uk/                          */</span>
00015 <span class="comment">/*                                                             */</span>
00016 <span class="comment">/*      Entropic Cambridge Research Laboratory                 */</span>
00017 <span class="comment">/*      (now part of Microsoft)                                */</span>
00018 <span class="comment">/*                                                             */</span>
00019 <span class="comment">/* ----------------------------------------------------------- */</span>
00020 <span class="comment">/*         Copyright: Microsoft Corporation                    */</span>
00021 <span class="comment">/*          1995-2000 Redmond, Washington USA                  */</span>
00022 <span class="comment">/*                    http://www.microsoft.com                 */</span>
00023 <span class="comment">/*                                                             */</span>
00024 <span class="comment">/*          2001-2002 Cambridge University                     */</span>
00025 <span class="comment">/*                    Engineering Department                   */</span>
00026 <span class="comment">/*                                                             */</span>
00027 <span class="comment">/*   Use of this software is governed by a License Agreement   */</span>
00028 <span class="comment">/*    ** See the file License for the Conditions of Use  **    */</span>
00029 <span class="comment">/*    **     This banner notice must not be removed      **    */</span>
00030 <span class="comment">/*                                                             */</span>
00031 <span class="comment">/* ----------------------------------------------------------- */</span>
00032 <span class="comment">/*         File: HShell.h:   Interface to the Shell            */</span>
00033 <span class="comment">/* ----------------------------------------------------------- */</span>
00034 
00035 <span class="comment">/* !HVER!HShell:   3.2.1 [CUED 15/10/03] */</span>
00036 
00037 <span class="preprocessor">#ifndef _HSHELL_H_</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define _HSHELL_H_</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#include &lt;stdio.h&gt;</span>         <span class="comment">/* Standard Libraries */</span>
00041 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00042 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00043 <span class="preprocessor">#include &lt;string.h&gt;</span>
00044 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00045 <span class="preprocessor">#include &lt;math.h&gt;</span>
00046 <span class="preprocessor">#include &lt;limits.h&gt;</span>
00047 <span class="preprocessor">#ifdef WIN32 </span><span class="comment">/* WIN32 modification */</span>
00048 <span class="preprocessor">#include &lt;time.h&gt;</span>
00049 <span class="preprocessor">#include &lt;Winsock2.h&gt;</span>
00050 <span class="preprocessor">#else</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00052 <span class="preprocessor">#endif</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#include &lt;errno.h&gt;</span>
00054 <span class="preprocessor">#include &lt;signal.h&gt;</span>
00055 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00056 
00057 <span class="preprocessor">#ifdef __cplusplus</span>
00058 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00059 <span class="preprocessor">#endif</span>
00060 <span class="preprocessor"></span>
00061 <span class="preprocessor">#if !defined UNIX &amp;&amp; !defined WIN32 &amp;&amp; !defined MPW &amp;&amp;!defined VMS</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#define UNIX     </span><span class="comment">/* Choices are UNIX, WIN32, MPW, VMS */</span>
00063 <span class="preprocessor">#endif</span>
00064 <span class="preprocessor"></span>
00065 <span class="preprocessor">#ifdef UNIX</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#include &lt;unistd.h&gt;</span>
00067 <span class="preprocessor">#include &lt;time.h&gt;</span>
00068 <span class="preprocessor">#endif</span>
00069 <span class="preprocessor"></span>
00070 
00071 <span class="preprocessor">#define MAXSTRLEN 256    </span><span class="comment">/* max length of a string */</span>
00072 <span class="preprocessor">#define MAXFNAMELEN 1034 </span><span class="comment">/* max length of a file name */</span>
00073 <span class="preprocessor">#define SMAX      5      </span><span class="comment">/* max num data streams + 1 */</span>
00074 <span class="preprocessor">#define MAXGLOBS  256    </span><span class="comment">/* max num global config parms */</span>
00075 
00076 <span class="preprocessor">#define SING_QUOTE '\''  </span><span class="comment">/* character used as quote */</span>
00077 <span class="preprocessor">#define DBL_QUOTE '"'    </span><span class="comment">/* character used as quote */</span>
00078 <span class="preprocessor">#define ESCAPE_CHAR '\\' </span><span class="comment">/* character used as escape */</span>
00079 
00080 <span class="preprocessor">#ifdef UNIX</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00082 <span class="preprocessor">#include &lt;sys/ioctl.h&gt;</span>
00083 <span class="preprocessor">#endif</span>
00084 <span class="preprocessor"></span>
00085 <span class="preprocessor">#undef FALSE</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#undef TRUE</span>
00087 <span class="preprocessor"></span>
00088 <span class="keyword">typedef</span> <span class="keywordtype">int</span> int32;
00089 
00090 <span class="keyword">typedef</span> <span class="keyword">enum</span> {FAIL=-1, SUCCESS=0} ReturnStatus;
00091 
00092 <span class="comment">/* Boolean type definition */</span>
00093 <span class="keyword">typedef</span> <span class="keyword">enum</span> {FALSE=0, TRUE=1} Boolean; 
00094 <span class="keyword">typedef</span> <span class="keyword">enum</span> {FLSE=0, TRU=1} Boolean1; 
00095 
00096 <span class="keyword">typedef</span> <span class="keywordtype">double</span> HTime;      <span class="comment">/* time in 100ns units */</span>
00097 
00098 <span class="keyword">typedef</span> <span class="keyword">enum</span>{       <span class="comment">/* Input filters for various types of file */</span>
00099    WaveFilter,      <span class="comment">/* waveforms input via HWave */</span>
00100    ParmFilter,      <span class="comment">/* parameter files input via HParm */</span>
00101    LangModFilter,   <span class="comment">/* language model files input via HLM */</span>
00102    HMMListFilter,   <span class="comment">/* HMM lists input via HModel */</span>
00103    HMMDefFilter,    <span class="comment">/* HMM definition files input via HModel */</span>
00104    LabelsFilter,    <span class="comment">/* Label files input via HLabel */</span>
00105    NetFilter,       <span class="comment">/* Network file input via HNet */</span>
00106    DictFilter,      <span class="comment">/* Dictionary file input via HDict */</span>
00107    LGramFilter,     <span class="comment">/* NGram Input via LGBase */</span>
00108    LWMapFilter,     <span class="comment">/* LM Word Map Input via LWMap */</span>
00109    LCMapFilter,     <span class="comment">/* LM Class Map Input */</span>
00110    LMTextFilter,    <span class="comment">/* LM source text input via LGPrep */</span>
00111    NoFilter,        <span class="comment">/* Direct input - no pipe */</span>
00112 
00113    WaveOFilter,     <span class="comment">/* waveforms output via HWave */</span>
00114    ParmOFilter,     <span class="comment">/* parameter files output via HParm */</span>
00115    LangModOFilter,  <span class="comment">/* language model files output via HLM */</span>
00116    HMMListOFilter,  <span class="comment">/* HMM lists output via HModel */</span>
00117    HMMDefOFilter,   <span class="comment">/* HMM definition files output via HModel */</span>
00118    LabelsOFilter,   <span class="comment">/* Label files output via HLabel */</span>
00119    NetOFilter,      <span class="comment">/* Network file output via HNet */</span>
00120    DictOFilter,     <span class="comment">/* Dictionary file output via HDict */</span>
00121    LGramOFilter,    <span class="comment">/* NGram Output via LGBase */</span>
00122    LWMapOFilter,    <span class="comment">/* LM Word Map Output via LWMap */</span>
00123    LCMapOFilter,    <span class="comment">/* LM Class Map Output */</span>
00124    NoOFilter        <span class="comment">/* Direct output - no pipe */</span>
00125 }IOFilter;
00126 
00127 
00128 <span class="keyword">typedef</span> <span class="keyword">struct </span>{     <span class="comment">/* Defines a source file with position tracking */</span>
00129    <span class="keywordtype">char</span> name[256];      <span class="comment">/* file name for error messages */</span>
00130    FILE *f;             <span class="comment">/* input stream */</span>
00131    Boolean isPipe;      <span class="comment">/* input is a pipe */</span>
00132    Boolean pbValid;     <span class="comment">/* true if putback holds char */</span>
00133    Boolean wasQuoted;   <span class="comment">/* true if ReadString returned quoted string */</span>
00134    Boolean wasNewline;  <span class="comment">/* true if SkipWhiteSpace went over newline */</span>
00135    <span class="keywordtype">int</span> putback;         <span class="comment">/* put back character */</span>
00136    <span class="keywordtype">int</span> chcount;         <span class="comment">/* num chars from start */</span>
00137 } Source;
00138 
00139 <span class="keyword">typedef</span> <span class="keyword">enum</span>{        <span class="comment">/* Type of configuration parameter */</span>
00140    StrCKind,            <span class="comment">/* string, optionally in dble quotes */</span>
00141    IntCKind,            <span class="comment">/* integer value - coercable to float */</span>
00142    FltCKind,            <span class="comment">/* float value */</span>
00143    BoolCKind,           <span class="comment">/* Boolean: T,F,True,False */</span>
00144    AnyCKind             <span class="comment">/* dont care */</span>
00145 } ConfKind;
00146 
00147 <span class="keyword">typedef</span> <span class="keyword">union </span>{      <span class="comment">/* union of possible config param kinds */</span>
00148    <span class="keywordtype">char</span> *s;
00149    <span class="keywordtype">int</span> i;
00150    <span class="keywordtype">double</span> f;
00151    Boolean b;
00152 }ConfVal;
00153 
00154 <span class="keyword">typedef</span> <span class="keyword">struct </span>{     <span class="comment">/* Configuration Parameter */</span>
00155    <span class="keywordtype">char</span> *user;          <span class="comment">/* name of module/tool to use this param */</span>
00156    <span class="keywordtype">char</span> *name;          <span class="comment">/* name of param - upper case always */</span>
00157    ConfKind kind;       <span class="comment">/* kind of config param value */</span>
00158    ConfVal val;         <span class="comment">/* value */</span>
00159    Boolean seen;        <span class="comment">/* set true when read by any module */</span>
00160 } ConfParam;
00161 
00162 
00163 <span class="comment">/* ---------------- Termination and error handling ------------------- */</span>
00164 
00165 <span class="keywordtype">void</span> Exit(<span class="keywordtype">int</span> exitcode);
00166 <span class="comment">/*</span>
00167 <span class="comment">   Exit from tool (and print termination diagnostics if required).</span>
00168 <span class="comment">*/</span>
00169 
00170 <span class="keywordtype">void</span> HError(<span class="keywordtype">int</span> errcode, <span class="keywordtype">char</span> *message, ...);
00171 <span class="comment">/*</span>
00172 <span class="comment">   Print the given message in 'printf' style, then if err &gt; 0 terminate</span>
00173 <span class="comment">   returning errcode as status.</span>
00174 <span class="comment">*/</span>
00175 
00176 <span class="keywordtype">void</span> HRError(<span class="keywordtype">int</span> errcode, <span class="keywordtype">char</span> *message, ...);
00177 <span class="comment">/* </span>
00178 <span class="comment">New function - print error message on stderr and don't abort.</span>
00179 <span class="comment">*/</span>
00180 
00181 
00182 <span class="comment">/* ------------------------ Initialisation --------------------------- */</span>
00183 
00184 
00185 <span class="keyword">extern</span> Boolean vaxOrder;  
00186 <span class="keyword">extern</span> Boolean flag;
00187 <span class="comment">/* </span>
00188 <span class="comment">   Global variable indicating VAX-order architecture for storing numbers </span>
00189 <span class="comment">*/</span>
00190 
00191 ReturnStatus InitShell(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[], <span class="keywordtype">char</span> *ver, <span class="keywordtype">char</span> *sccs);
00192 <span class="comment">/* </span>
00193 <span class="comment">   Called from main to initialise module and store command line parameters </span>
00194 <span class="comment">   for subsequent access by following xxxArg routines.  The following</span>
00195 <span class="comment">   standard command line options are processed immediately by InitShell</span>
00196 <span class="comment">   and then deleted from the command line:</span>
00197 <span class="comment">      -A                   print command line arguments</span>
00198 <span class="comment">      -C configfile        load given configuration file</span>
00199 <span class="comment">      -D                   display config parameters</span>
00200 <span class="comment">      -S scriptfile        append the given script file</span>
00201 <span class="comment">      -V                   print version and sccs info and abort</span>
00202 <span class="comment">   ver and sccs are the HTK version info ver and sccs info for the</span>
00203 <span class="comment">   current tool.</span>
00204 <span class="comment">*/</span>
00205 
00206 <span class="keywordtype">void</span> Register(<span class="keywordtype">char</span> *ver, <span class="keywordtype">char</span> *sccs);
00207 <span class="comment">/*</span>
00208 <span class="comment">   Register module version and sccs info.</span>
00209 <span class="comment">   This information is used by PrintVersion.  It is called by</span>
00210 <span class="comment">   each module's Init routine.</span>
00211 <span class="comment">*/</span>
00212 
00213 Boolean InfoPrinted(<span class="keywordtype">void</span>);
00214 <span class="comment">/*</span>
00215 <span class="comment">   Returns true if Shell has printed out information via one</span>
00216 <span class="comment">   of the special commands -A, -B or -V.  This MUST be called</span>
00217 <span class="comment">   immediately after Initialising all modules since it executes</span>
00218 <span class="comment">   a pending -V request, if any.</span>
00219 <span class="comment">*/</span>
00220 
00221 <span class="keywordtype">void</span> PrintStdOpts(<span class="keywordtype">char</span> *opts);
00222 <span class="comment">/*</span>
00223 <span class="comment">   Print standard command line options - as above.  Additional</span>
00224 <span class="comment">   standard options (ie capital letter options not implemented</span>
00225 <span class="comment">   directly by the shell) must be listed in opts from the </span>
00226 <span class="comment">   following set:</span>
00227 <span class="comment">       -B      Save HMM macro files as binary</span>
00228 <span class="comment">       -F fmt  Set source format to fmt </span>
00229 <span class="comment">       -G fmt  Set source label format to fmt</span>
00230 <span class="comment">       -H mmf  Load HMM macro file mmf</span>
00231 <span class="comment">       -I mlf  Load master label file mlf</span>
00232 <span class="comment">       -L dir  Dir holding label files</span>
00233 <span class="comment">       -M      Dir to write HMM macro files</span>
00234 <span class="comment">       -O      Set target data format to fmt</span>
00235 <span class="comment">       -P      Set target label format to fmt</span>
00236 <span class="comment">       -Q      Print command summary</span>
00237 <span class="comment">       -X ext  Set label file extension to ext</span>
00238 <span class="comment">   Only exception to this is -T which is always printed.</span>
00239 <span class="comment">*/</span>
00240 
00241 <span class="comment">/* ------------- Configuration Parameter File Handling --------------- */</span>
00242 
00243 <span class="keywordtype">void</span> PrintConfig(<span class="keywordtype">void</span>);
00244 <span class="comment">/*</span>
00245 <span class="comment">   Print the current configuration and usage</span>
00246 <span class="comment">*/</span>
00247 
00248 <span class="keywordtype">int</span> GetConfig(<span class="keywordtype">char</span> *user, Boolean incGlob, ConfParam **list, <span class="keywordtype">int</span> max);
00249 <span class="comment">/*</span>
00250 <span class="comment">    Store a list of upto max configuration parameters whose user name</span>
00251 <span class="comment">    matches the user and return the number of parameters stored.  If</span>
00252 <span class="comment">    list is NULL then just return the number of parameters that would</span>
00253 <span class="comment">    have been stored.  If incGlob then global parameters are</span>
00254 <span class="comment">    included.  If user is NULL then all parameters are returned.</span>
00255 <span class="comment">    If max is exceeded then an error occurs.</span>
00256 <span class="comment">*/</span>
00257 
00258 Boolean HasConfParm(ConfParam **list, <span class="keywordtype">int</span> size, <span class="keywordtype">char</span> *name);
00259 Boolean GetConfStr(ConfParam **list,<span class="keywordtype">int</span> size,<span class="keywordtype">char</span> *name, <span class="keywordtype">char</span> *str);
00260 Boolean GetConfBool(ConfParam **list,<span class="keywordtype">int</span> size,<span class="keywordtype">char</span> *name, Boolean *b);
00261 Boolean GetConfInt(ConfParam **list,<span class="keywordtype">int</span> size,<span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> *ival);
00262 Boolean GetConfFlt(ConfParam **list,<span class="keywordtype">int</span> size,<span class="keywordtype">char</span> *name, <span class="keywordtype">double</span> *fval);
00263 <span class="comment">/*</span>
00264 <span class="comment">   Access routines for the array of size ConfParam elements returned</span>
00265 <span class="comment">   by GetConfig.  Returns true if name is found.  Generates an error</span>
00266 <span class="comment">   if kind is different</span>
00267 <span class="comment">*/</span>
00268 
00269 <span class="comment">/* ----------------- Command Line Argument Handling ------------------ */</span>
00270 
00271 <span class="keyword">typedef</span> <span class="keyword">enum</span> {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;
00272 
00273 <span class="keywordtype">int</span>  NumArgs(<span class="keywordtype">void</span>);
00274 <span class="comment">/*</span>
00275 <span class="comment">   Returns number of command line args which have not yet been processed.</span>
00276 <span class="comment">   Initially this is equal to argc-1 since actual command name is ignored</span>
00277 <span class="comment">*/</span>
00278 
00279 ArgKind NextArg(<span class="keywordtype">void</span>);
00280 <span class="comment">/*</span>
00281 <span class="comment">   Returns the kind of the next command line argument.  If NumArgs()==0 then</span>
00282 <span class="comment">   NOARG will be returned. </span>
00283 <span class="comment">*/</span>
00284 
00285 <span class="keywordtype">char</span> * GetStrArg(<span class="keywordtype">void</span>);
00286 <span class="keywordtype">char</span> * GetSwtArg(<span class="keywordtype">void</span>);
00287 <span class="keywordtype">int</span>    GetIntArg(<span class="keywordtype">void</span>);
00288 <span class="keywordtype">long</span>   GetLongArg(<span class="keywordtype">void</span>);
00289 <span class="keywordtype">float</span>  GetFltArg(<span class="keywordtype">void</span>);
00290 <span class="comment">/*</span>
00291 <span class="comment">   Return value of next arg and 'consume' that arg.  An error is raised if</span>
00292 <span class="comment">   the kind of the next arg is different to that requested except that </span>
00293 <span class="comment">   GetFltArg will accept either an integer or a float argument</span>
00294 <span class="comment">*/</span>
00295 
00296 <span class="keywordtype">int</span>   GetChkedInt(<span class="keywordtype">int</span> min, <span class="keywordtype">int</span> max, <span class="keywordtype">char</span> * swtname);
00297 <span class="keywordtype">long</span>   GetChkedLong(<span class="keywordtype">long</span> min, <span class="keywordtype">long</span> max, <span class="keywordtype">char</span> * swtname);
00298 <span class="keywordtype">float</span> GetChkedFlt(<span class="keywordtype">float</span> min, <span class="keywordtype">float</span> max, <span class="keywordtype">char</span> * swtname);
00299 <span class="comment">/* </span>
00300 <span class="comment">   Range checked versions of GetIntArg and GetFltArg.  Swtname</span>
00301 <span class="comment">   is the name of the preceding switch and is only used in</span>
00302 <span class="comment">   error message.</span>
00303 <span class="comment">*/</span>
00304 
00305 Boolean GetIntEnvVar(<span class="keywordtype">char</span> *envVar, <span class="keywordtype">int</span> *value);
00306 <span class="comment">/*</span>
00307 <span class="comment">   Get the integer value of env variable envVar.</span>
00308 <span class="comment">   Returns false if envVar not set</span>
00309 <span class="comment">*/</span>
00310 
00311 Boolean GetFileNameExt(<span class="keywordtype">char</span> *logfn, <span class="keywordtype">char</span> *actfn, <span class="keywordtype">long</span> *st, <span class="keywordtype">long</span> *en);
00312 <span class="comment">/* </span>
00313 <span class="comment">   Return true if given file has extensions, i.e. an alias and/or st/end</span>
00314 <span class="comment">   indices.  If true actual file name is copied into actfn and indices</span>
00315 <span class="comment">   are copied into st and en.   Extended file names have the form</span>
00316 <span class="comment">             file[1,999]</span>
00317 <span class="comment">   or        logfile=actfile</span>
00318 <span class="comment">   or        logfile=actfile[1,999]</span>
00319 <span class="comment">     </span>
00320 <span class="comment">   File extensions can be disabled by seting EXTENDFILENAMES to F</span>
00321 <span class="comment">*/</span>       
00322 
00323 <span class="comment">/* ---------------------- Input Handling ----------------------------- */</span>
00324 
00325 FILE *FOpen(<span class="keywordtype">char</span> *fname, IOFilter filter, Boolean *isPipe);
00326 <span class="comment">/*</span>
00327 <span class="comment">   Open the file fname for reading or writing (depending on</span>
00328 <span class="comment">   whether IOFilter is a Filter or OFilter) and return a file pointer.  </span>
00329 <span class="comment">   If the environment variable HxxxxFILTER is set to a </span>
00330 <span class="comment">   command of the form "foo $ a b ..." then the given fname</span>
00331 <span class="comment">   replaces the $ and popen is used to connect to the output</span>
00332 <span class="comment">   of foo. The Boolean isPipe returns true if input is a pipe.</span>
00333 <span class="comment">   In addition, if the environment variable HMAXTRY is set to</span>
00334 <span class="comment">   an integer n, then an fopen call which fails will be retried</span>
00335 <span class="comment">   n-1 more times before failing completely.  This is useful </span>
00336 <span class="comment">   in combatting occassional NFS errors.</span>
00337 <span class="comment">*/</span>
00338 
00339 <span class="keywordtype">void</span> FClose(FILE *f, Boolean isPipe);
00340 <span class="comment">/*</span>
00341 <span class="comment">   Close the given file or pipe</span>
00342 <span class="comment">*/</span>
00343 
00344 ReturnStatus InitSource(<span class="keywordtype">char</span> *fname, Source *src, IOFilter filter);
00345 <span class="comment">/*</span>
00346 <span class="comment">   Initialise a text source using file fname and filter - returns</span>
00347 <span class="comment">*/</span>
00348 
00349 <span class="keywordtype">void</span> CloseSource(Source *src);
00350 <span class="comment">/*</span>
00351 <span class="comment">   Close source</span>
00352 <span class="comment">*/</span>
00353 
00354 <span class="keywordtype">void</span> AttachSource(FILE *file, Source *src);
00355 <span class="comment">/*</span>
00356 <span class="comment">   Attach a source to already open file</span>
00357 <span class="comment">*/</span>
00358 
00359 <span class="keywordtype">char</span> *SrcPosition(Source src, <span class="keywordtype">char</span> *s);
00360 <span class="comment">/* </span>
00361 <span class="comment">   return string describing the current position in src</span>
00362 <span class="comment">*/</span>
00363 
00364 <span class="keywordtype">int</span>  GetCh(Source *src);
00365 <span class="keywordtype">void</span> UnGetCh(<span class="keywordtype">int</span> c, Source *src);
00366 <span class="comment">/*</span>
00367 <span class="comment">   Get/Unget a character from the given source </span>
00368 <span class="comment">*/</span>
00369 
00370 Boolean ReadString(Source *src, <span class="keywordtype">char</span> *s);
00371 Boolean ReadStringWithLen(Source *src, <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> buflen); <span class="comment">/* With specified length of buffer*/</span>
00372 <span class="keywordtype">char</span> *ParseString(<span class="keywordtype">char</span> *src, <span class="keywordtype">char</span> *s);
00373 <span class="comment">/*</span>
00374 <span class="comment">   Read a string from the given source where a string is any</span>
00375 <span class="comment">   sequence of non-white space characters, or any sequence of</span>
00376 <span class="comment">   characters enclosed by single or double quotes.</span>
00377 <span class="comment">   Also supports use of escape character to allow quotes to appear</span>
00378 <span class="comment">   within the string and also to allow three digit octal specification</span>
00379 <span class="comment">   of any character.  </span>
00380 <span class="comment">   Return TRUE (for ReadString) or pointer to next unread character</span>
00381 <span class="comment">   (for ParseString) if no error.</span>
00382 <span class="comment">   '"QUOTE' "\"QUOTE" \"QUOTE \042QUOTE all return "QUOTE in s</span>
00383 <span class="comment">*/</span>
00384 
00385 Boolean ReadRawString(Source *src, <span class="keywordtype">char</span> *s);
00386 <span class="comment">/* </span>
00387 <span class="comment">   Read a raw string (i.e. word upto next white-space) from src and store it in s </span>
00388 <span class="comment">*/</span>
00389 
00390 <span class="keywordtype">void</span> WriteString(FILE *f,<span class="keywordtype">char</span> *s,<span class="keywordtype">char</span> q);
00391 <span class="keywordtype">char</span> *ReWriteString(<span class="keywordtype">char</span> *s,<span class="keywordtype">char</span> *dst, <span class="keywordtype">char</span> q);
00392 <span class="comment">/*</span>
00393 <span class="comment">   Write string s in ReadString format (with quotes and escapes as</span>
00394 <span class="comment">   needed).  Either writes direct to file (WriteString), to supplied</span>
00395 <span class="comment">   buffer (dst!=NULL) or to static buffer (dst==NULL).</span>
00396 <span class="comment">   q can either be SING_QUOTE, DBL_QUOTE to force quoting of string</span>
00397 <span class="comment">   or 0 to quote strings that contain quotes, or ESCAPE_CHAR to never</span>
00398 <span class="comment">   quote the string. </span>
00399 <span class="comment">*/</span>
00400 
00401 Boolean SkipLine(Source *src);
00402 <span class="comment">/* </span>
00403 <span class="comment">   skip to next line in source, return FALSE when EOF reached</span>
00404 <span class="comment">*/</span>
00405 
00406 Boolean ReadLine(Source *src,<span class="keywordtype">char</span> *s);
00407 <span class="comment">/* </span>
00408 <span class="comment">   read to next newline in source, return FALSE when EOF reached</span>
00409 <span class="comment">*/</span>
00410 
00411 <span class="keywordtype">void</span> ReadUntilLine (Source *src, <span class="keywordtype">char</span> *s);
00412 <span class="comment">/* </span>
00413 <span class="comment">   read to next occurrence of string </span>
00414 <span class="comment">*/</span>
00415 
00416 <span class="keywordtype">void</span> SkipWhiteSpace(Source *src);
00417 <span class="comment">/* </span>
00418 <span class="comment">   skip white space (if any)</span>
00419 <span class="comment">   if any space is skipped sets wasNewline to indicate if the space</span>
00420 <span class="comment">   contained a newline character</span>
00421 <span class="comment">*/</span>
00422 
00423 <span class="keywordtype">void</span> SkipComment(Source *src);
00424 <span class="comment">/* </span>
00425 <span class="comment">   skip to next non-blank, if it is a # then skip to next line</span>
00426 <span class="comment">*/</span>
00427 
00428 Boolean ReadShort(Source *src, <span class="keywordtype">short</span> *s, <span class="keywordtype">int</span> n, Boolean binary);
00429 Boolean ReadInt  (Source *src, <span class="keywordtype">int</span> *i,   <span class="keywordtype">int</span> n, Boolean binary);
00430 Boolean ReadFloat(Source *src, <span class="keywordtype">float</span> *x, <span class="keywordtype">int</span> n, Boolean binary);
00431 <span class="comment">/*</span>
00432 <span class="comment">   Read n short/int/float(s) from the given source, return </span>
00433 <span class="comment">   TRUE if no error.  If binary then binary read is performed - </span>
00434 <span class="comment">   byte swapping is controlled by HShell config variables.</span>
00435 <span class="comment">*/</span>
00436 Boolean RawReadShort(Source *src, <span class="keywordtype">short</span> *s, <span class="keywordtype">int</span> n, Boolean bin, Boolean swap);
00437 Boolean RawReadInt(Source *src, <span class="keywordtype">int</span> *i, <span class="keywordtype">int</span> n, Boolean bin, Boolean swap);
00438 Boolean RawReadFloat(Source *src, <span class="keywordtype">float</span> *x, <span class="keywordtype">int</span> n, Boolean bin, Boolean swap);
00439 <span class="comment">/*</span>
00440 <span class="comment">   Read n short/int/float(s) from the given source, return </span>
00441 <span class="comment">   TRUE if no error.  </span>
00442 <span class="comment">   If binary then binary read is performed.</span>
00443 <span class="comment">   If swap then values are byte swapped after reading.</span>
00444 <span class="comment">*/</span>
00445 
00446 <span class="keywordtype">void</span> SwapShort(<span class="keywordtype">short</span> *p);
00447 <span class="keywordtype">void</span> SwapInt32(int32 *p);
00448 <span class="comment">/* </span>
00449 <span class="comment">   Byte swap various types</span>
00450 <span class="comment">*/</span>
00451 
00452 Boolean KeyPressed(<span class="keywordtype">int</span> tWait);
00453 <span class="comment">/*</span>
00454 <span class="comment">   Returns TRUE if input is pending on stdin within tWait seconds</span>
00455 <span class="comment">*/</span>   
00456 
00457 <span class="comment">/* -------------------------- Output Handling ------------------------ */</span>
00458 
00459 <span class="keywordtype">void</span> WriteShort(FILE *f, <span class="keywordtype">short</span> *s, <span class="keywordtype">int</span> n, Boolean binary);
00460 <span class="keywordtype">void</span> WriteInt  (FILE *f, <span class="keywordtype">int</span> *i,   <span class="keywordtype">int</span> n, Boolean binary);
00461 <span class="keywordtype">void</span> WriteFloat(FILE *f, <span class="keywordtype">float</span> *x, <span class="keywordtype">int</span> n, Boolean binary);
00462 <span class="comment">/*</span>
00463 <span class="comment">   Write n short/int/float(s) to the given file.  </span>
00464 <span class="comment">   If binary then binary Write is performed.</span>
00465 <span class="comment">*/</span>
00466 
00467 <span class="comment">/* ---------------------- File Name Manipulation --------------------- */</span>
00468 
00469 <span class="preprocessor">#if defined MPW</span>
00470 <span class="preprocessor"></span><span class="preprocessor">#define PATHCHAR ':'</span>
00471 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00472 <span class="preprocessor"></span><span class="preprocessor">#if defined UNIX</span>
00473 <span class="preprocessor"></span><span class="preprocessor">#define PATHCHAR '/'</span>
00474 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00475 <span class="preprocessor"></span><span class="preprocessor">#if defined WIN32</span>
00476 <span class="preprocessor"></span><span class="preprocessor">#define PATHCHAR '/'</span>
00477 <span class="preprocessor"></span><span class="preprocessor">#define ALTPATHCHAR '\\'</span>
00478 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00479 <span class="preprocessor"></span><span class="preprocessor">#if defined VMS</span>
00480 <span class="preprocessor"></span><span class="preprocessor">#define PATHCHAR ']'</span>
00481 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00482 <span class="preprocessor"></span>
00483 <span class="keywordtype">char</span> * NameOf(<span class="keywordtype">char</span> *fn, <span class="keywordtype">char</span> *s);
00484 <span class="keywordtype">char</span> * BaseOf(<span class="keywordtype">char</span> *fn, <span class="keywordtype">char</span> *s);
00485 <span class="keywordtype">char</span> * PathOf(<span class="keywordtype">char</span> *fn, <span class="keywordtype">char</span> *s);
00486 <span class="keywordtype">char</span> * ExtnOf(<span class="keywordtype">char</span> *fn, <span class="keywordtype">char</span> *s);
00487 <span class="comment">/*</span>
00488 <span class="comment">   Given a filename of the general form "path/n.x" in fn, the above</span>
00489 <span class="comment">   functions return "n.x", "n", "x" and "path/", respectively. In each case,</span>
00490 <span class="comment">   the string is returned in s which must be large enough and s is returned</span>
00491 <span class="comment">   as the function result.</span>
00492 <span class="comment">*/</span>
00493 
00494 <span class="keywordtype">char</span> * MakeFN(<span class="keywordtype">char</span> *fn, <span class="keywordtype">char</span> *path, <span class="keywordtype">char</span> *ext, <span class="keywordtype">char</span> *s);
00495 <span class="comment">/*</span>
00496 <span class="comment">   The supplied file name fn is used as a template for constructing a </span>
00497 <span class="comment">   new file name returned in s as function result.  The construction</span>
00498 <span class="comment">   rules are as follows:</span>
00499 <span class="comment">      a) if path is not NULL then any path is stripped from fn and</span>
00500 <span class="comment">         replaced by the given path</span>
00501 <span class="comment">      b) if ext is not NULL then any extension is stripped from fn </span>
00502 <span class="comment">         and replaced by the given extension</span>
00503 <span class="comment">*/</span>
00504 
00505 <span class="keywordtype">char</span> * CounterFN(<span class="keywordtype">char</span> *prefix, <span class="keywordtype">char</span>* suffix, <span class="keywordtype">int</span> count, <span class="keywordtype">int</span> width, <span class="keywordtype">char</span> *s);
00506 <span class="comment">/*</span>
00507 <span class="comment">   creates a file name in s of form "PREFNNNSUF" where NNNN is count </span>
00508 <span class="comment">   expressed in width digits with leading zeroes if needed.</span>
00509 <span class="comment">*/</span>
00510 
00511 
00512 <span class="keywordtype">void</span> SubstFName(<span class="keywordtype">char</span> *fname, <span class="keywordtype">char</span> *s);
00513 <span class="comment">/* </span>
00514 <span class="comment">   Subst fname for any occurrences of $ in s which must be large</span>
00515 <span class="comment">   enough to accommodate the expanded string</span>
00516 <span class="comment">*/</span>
00517 
00518 <span class="comment">/* ------------------------ Pattern Matching ------------------------- */</span>
00519 
00520 Boolean DoMatch(<span class="keywordtype">char</span> *s, <span class="keywordtype">char</span> *p);
00521 <span class="comment">/* </span>
00522 <span class="comment">   Returns true if the string s matches the pattern p.</span>
00523 <span class="comment">   The pattern p may contain the metacharacters '?'</span>
00524 <span class="comment">   which will match exactly 1 character and '*'</span>
00525 <span class="comment">   which will match zero or more characters.</span>
00526 <span class="comment">*/</span>
00527 
00528 Boolean MaskMatch(<span class="keywordtype">char</span> *mask, <span class="keywordtype">char</span> *spkr, <span class="keywordtype">char</span> *str);
00529 <span class="comment">/* Returns true if the string str matches the pattern.</span>
00530 <span class="comment">   The string matched to the '%' is returned in spkr.</span>
00531 <span class="comment">*/</span>
00532 
00533 <span class="keywordtype">char</span> *RetrieveCommandLine(<span class="keywordtype">void</span>);
00534 <span class="comment">/*</span>
00535 <span class="comment">   Retrieves the savedCommandLine, that contains the</span>
00536 <span class="comment">   actual command line used to run the program at hand.</span>
00537 <span class="comment">*/</span>
00538 
00539 <span class="preprocessor">#ifdef __cplusplus</span>
00540 <span class="preprocessor"></span>}
00541 <span class="preprocessor">#endif</span>
00542 <span class="preprocessor"></span>
00543 
00544 <span class="comment">/* ----------------------- Timing functions for diagnostics ----------- */</span>
00545 <span class="preprocessor">#ifndef WIN32</span>
00546 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>TimeStruct_s {
00547    <span class="keywordtype">char</span> timestr[50];
00548    <span class="keyword">struct </span>timeval time;
00549    clock_t clock_time;
00550 } TimeStruct;
00551 
00552 <span class="keywordtype">void</span> SetTime(TimeStruct *t);
00553 
00554 <span class="keywordtype">char</span> *GiveTime(TimeStruct *t);  <span class="comment">/* Gives CPU and clock time elapsed in seconds</span>
00555 <span class="comment">                                   since SetTime was called on t,</span>
00556 <span class="comment">                                   in format "?.????/clock ?.????" . */</span>
00557 <span class="preprocessor">#endif  </span><span class="comment">/* WIN32 */</span>
00558 <span class="preprocessor">#endif  </span><span class="comment">/* _HSHELL_H_ */</span>
00559 
00560 <span class="comment">/* ----------------------- End of HShell.h --------------------------- */</span>
</pre></div><hr><address style="align: right;"><small>
Generated on Tue Jul 1 18:54:50 2008 for OCR by <a href="http://www.mpp.org.np">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 width=110 height=53>
</a>    </small></address>
</body>
</html>
